<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="eep_8c" kind="file" language="C++">
    <compoundname>eep.c</compoundname>
    <includes refid="eep_8h" local="yes">eep.h</includes>
    <includes refid="nt3h_8h" local="yes">nt3h.h</includes>
    <includes refid="defs_8h" local="yes">defs.h</includes>
    <incdepgraph>
      <node id="24">
        <label>eep.c</label>
        <link refid="eep_8c"/>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
      </node>
      <node id="25">
        <label>eep.h</label>
        <link refid="eep_8h"/>
      </node>
      <node id="26">
        <label>nt3h.h</label>
        <link refid="nt3h_8h"/>
      </node>
      <node id="27">
        <label>defs.h</label>
        <link refid="defs_8h"/>
      </node>
    </incdepgraph>
      <sectiondef kind="define">
      <memberdef kind="define" id="eep_8c_1ab8ef3b0a4427401a76129d6b15921f46" prot="public" static="no">
        <name>BUFSIZE_BLKS</name>
        <initializer>4</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="5" column="9" bodyfile="eep.c" bodystart="5" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="eep_8c_1a6e5ecf6e2d74f95a32e7f636bcbdf27f" prot="public" static="no">
        <name>BUFSIZE_BYTES</name>
        <initializer>(<ref refid="eep_8c_1ab8ef3b0a4427401a76129d6b15921f46" kindref="member">BUFSIZE_BLKS</ref> * <ref refid="defs_8h_1ac4551bbc9efabf8378f35498f80b4679" kindref="member">BLKSIZE</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="6" column="9" bodyfile="eep.c" bodystart="6" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="eep_8c_1a75ee6794c00b84590fc80f1d36a2ad24" prot="public" static="no" mutable="no">
        <type>char</type>
        <definition>char _blkbuffer[BUFSIZE_BLKS *BLKSIZE]</definition>
        <argsstring>[BUFSIZE_BLKS *BLKSIZE]</argsstring>
        <name>_blkbuffer</name>
        <initializer>= {0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="8" column="1" bodyfile="eep.c" bodystart="8" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="eep_8c_1a9f348aacb30d157e4f44c462bec60cfe" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int inbounds</definition>
        <argsstring>(int byteindex)</argsstring>
        <name>inbounds</name>
        <param>
          <type>int</type>
          <declname>byteindex</declname>
        </param>
        <briefdescription>
<para>Checks if a byte index is within the bounds the buffer array. </para>        </briefdescription>
        <detaileddescription>
<para>This can be used to prevent the program from accessing memory that is out of bounds.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>byteindex</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of a buffer byte that is to be read or written. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if the index is less than the size of the buffer and can be accessed safely. Otherwise 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="18" column="1" bodyfile="eep.c" bodystart="18" bodyend="21"/>
      </memberdef>
      <memberdef kind="function" id="eep_8c_1a9dc9545f49f34a394bf02e1a50ec94ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int eep_write</definition>
        <argsstring>(const int eepblk, const unsigned int bufblk)</argsstring>
        <name>eep_write</name>
        <param>
          <type>const int</type>
          <declname>eepblk</declname>
        </param>
        <param>
          <type>const unsigned int</type>
          <declname>bufblk</declname>
        </param>
        <briefdescription>
<para>Write a 16-byte block from the buffer to EEPROM. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eepblk</parametername>
</parameternamelist>
<parameterdescription>
<para>Block of the EEPROM to write to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bufblk</parametername>
</parameternamelist>
<parameterdescription>
<para>Block of the buffer to write from.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if the block to be written greater than the buffer size. Otherwise 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="29" column="1" bodyfile="eep.c" bodystart="29" bodyend="40"/>
      </memberdef>
      <memberdef kind="function" id="eep_8c_1a8750cd7456d517ba12af997c741bac94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eep_waitwritedone</definition>
        <argsstring>()</argsstring>
        <name>eep_waitwritedone</name>
        <briefdescription>
<para>Block until the EEPROM block write has finished. </para>        </briefdescription>
        <detaileddescription>
<para>Writes of Flash memory take some milliseconds to complete. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="46" column="1" bodyfile="eep.c" bodystart="46" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="eep_8c_1a8b26a063120afe56d2938c9e4d0c9972" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int eep_read</definition>
        <argsstring>(const int eepblk, const unsigned int bufblk)</argsstring>
        <name>eep_read</name>
        <param>
          <type>const int</type>
          <declname>eepblk</declname>
        </param>
        <param>
          <type>const unsigned int</type>
          <declname>bufblk</declname>
        </param>
        <briefdescription>
<para>Read a 16-byte block from EEPROM to the buffer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eepblk</parametername>
</parameternamelist>
<parameterdescription>
<para>EEPROM block to read. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bufblk</parametername>
</parameternamelist>
<parameterdescription>
<para>Block of the buffer to copy the EEPROM contents to. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="55" column="1" bodyfile="eep.c" bodystart="55" bodyend="66"/>
      </memberdef>
      <memberdef kind="function" id="eep_8c_1a8cd332f8cc6c3f1c02fd4632ea253199" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int eep_cp</definition>
        <argsstring>(int *indexptr, const char *dataptr, const int lenbytes)</argsstring>
        <name>eep_cp</name>
        <param>
          <type>int *</type>
          <declname>indexptr</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dataptr</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>lenbytes</declname>
        </param>
        <briefdescription>
<para>Copy data from a pointer into the buffer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>indexptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Data are copied into the buffer starting from this index. An integer from 0 to N-1, where N is the size of the buffer. indexptr is overwritten by the index one greater than the last data to be written. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dataptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Data are copied from this pointer. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lenbytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes to copy into the buffer from dataptr. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if the data to be copied will fit entirely in the buffer. Otherwise 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="76" column="1" bodyfile="eep.c" bodystart="76" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="eep_8c_1a792afc39f1a399b46b5dd4040b090184" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int eep_cpbyte</definition>
        <argsstring>(int *indexptr, const char bytedata)</argsstring>
        <name>eep_cpbyte</name>
        <param>
          <type>int *</type>
          <declname>indexptr</declname>
        </param>
        <param>
          <type>const char</type>
          <declname>bytedata</declname>
        </param>
        <briefdescription>
<para>Copy one byte into the buffer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>indexptr</parametername>
</parameternamelist>
<parameterdescription>
<para>The byte is copied into this index of the buffer. An integer from 0 to N-1, where N is the size of the buffer. indexptr is overwritten by indexptr+1. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bytedata</parametername>
</parameternamelist>
<parameterdescription>
<para>Byte to be copied into the buffer. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if indexptr is an index that will not overflow the buffer. Otherwise 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="eep.c" line="103" column="1" bodyfile="eep.c" bodystart="103" bodyend="115"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;<ref refid="eep_8h" kindref="compound">eep.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="nt3h_8h" kindref="compound">nt3h.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="defs_8h" kindref="compound">defs.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>BUFSIZE_BLKS<sp/><sp/>4</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>BUFSIZE_BYTES<sp/>(BUFSIZE_BLKS<sp/>*<sp/>BLKSIZE)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/><ref refid="eep_8c_1a75ee6794c00b84590fc80f1d36a2ad24" kindref="member">_blkbuffer</ref>[<ref refid="eep_8c_1ab8ef3b0a4427401a76129d6b15921f46" kindref="member">BUFSIZE_BLKS</ref><sp/>*<sp/><ref refid="defs_8h_1ac4551bbc9efabf8378f35498f80b4679" kindref="member">BLKSIZE</ref>]<sp/>=<sp/>{0};</highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>inbounds(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>byteindex)</highlight></codeline>
<codeline lineno="19"><highlight class="normal">{</highlight></codeline>
<codeline lineno="20"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((byteindex<sp/>&gt;=<sp/>0)<sp/>&amp;&amp;<sp/>(byteindex<sp/>&lt;<sp/><ref refid="eep_8c_1a6e5ecf6e2d74f95a32e7f636bcbdf27f" kindref="member">BUFSIZE_BYTES</ref>));</highlight></codeline>
<codeline lineno="21"><highlight class="normal">}</highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="eep_8c_1a9dc9545f49f34a394bf02e1a50ec94ce" kindref="member">eep_write</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>eepblk,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bufblk)</highlight></codeline>
<codeline lineno="30"><highlight class="normal">{</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>errflag<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>startbyte<sp/>=<sp/>bufblk<sp/>*<sp/><ref refid="defs_8h_1ac4551bbc9efabf8378f35498f80b4679" kindref="member">BLKSIZE</ref>;</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufblk<sp/>&lt;<sp/><ref refid="eep_8c_1ab8ef3b0a4427401a76129d6b15921f46" kindref="member">BUFSIZE_BLKS</ref>)</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="nt3h_8c_1a8b7f3ba6ec6dce05a9c79d4b08fa17bb" kindref="member">nt3h_writetag</ref>(eepblk+1,<sp/>&amp;<ref refid="eep_8c_1a75ee6794c00b84590fc80f1d36a2ad24" kindref="member">_blkbuffer</ref>[startbyte]);</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/>errflag<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>errflag;</highlight></codeline>
<codeline lineno="40"><highlight class="normal">}</highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="eep_8c_1a8750cd7456d517ba12af997c741bac94" kindref="member">eep_waitwritedone</ref>()</highlight></codeline>
<codeline lineno="47"><highlight class="normal">{</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(<ref refid="nt3h_8c_1af5eae3ef1e64f9f5e399840c02f871ad" kindref="member">nt3h_eepromwritedone</ref>()<sp/>!=<sp/>0);</highlight></codeline>
<codeline lineno="49"><highlight class="normal">}</highlight></codeline>
<codeline lineno="50"><highlight class="normal"></highlight></codeline>
<codeline lineno="55"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="eep_8c_1a8b26a063120afe56d2938c9e4d0c9972" kindref="member">eep_read</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>eepblk,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bufblk)</highlight></codeline>
<codeline lineno="56"><highlight class="normal">{</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>errflag<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>startbyte<sp/>=<sp/>bufblk<sp/>*<sp/><ref refid="defs_8h_1ac4551bbc9efabf8378f35498f80b4679" kindref="member">BLKSIZE</ref>;</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufblk<sp/>&lt;<sp/><ref refid="eep_8c_1ab8ef3b0a4427401a76129d6b15921f46" kindref="member">BUFSIZE_BLKS</ref>)</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="nt3h_8c_1a6766a3db85cd67a81ef911acff226dd8" kindref="member">nt3h_readtag</ref>(eepblk+1,<sp/>&amp;<ref refid="eep_8c_1a75ee6794c00b84590fc80f1d36a2ad24" kindref="member">_blkbuffer</ref>[startbyte]);</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/>errflag<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="64"><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>errflag;</highlight></codeline>
<codeline lineno="66"><highlight class="normal">}</highlight></codeline>
<codeline lineno="67"><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="eep_8c_1a8cd332f8cc6c3f1c02fd4632ea253199" kindref="member">eep_cp</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>indexptr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>dataptr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lenbytes)</highlight></codeline>
<codeline lineno="77"><highlight class="normal">{</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>startbyte<sp/>=<sp/>*indexptr;</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>endbyte<sp/>=<sp/>startbyte<sp/>+<sp/>lenbytes<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>errflag<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(inbounds(startbyte)<sp/>&amp;&amp;<sp/>inbounds(endbyte))</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i=0;<sp/>i&lt;lenbytes;<sp/>i++)</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="eep_8c_1a75ee6794c00b84590fc80f1d36a2ad24" kindref="member">_blkbuffer</ref>[startbyte<sp/>+<sp/>i]<sp/>=<sp/>*(dataptr<sp/>+<sp/>i);</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/>*indexptr<sp/>=<sp/>endbyte<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/>errflag<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="92"><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>errflag;</highlight></codeline>
<codeline lineno="94"><highlight class="normal">}</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="eep_8c_1a792afc39f1a399b46b5dd4040b090184" kindref="member">eep_cpbyte</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>indexptr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>bytedata)</highlight></codeline>
<codeline lineno="104"><highlight class="normal">{</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>errflag<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(inbounds(*indexptr))</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="eep_8c_1a75ee6794c00b84590fc80f1d36a2ad24" kindref="member">_blkbuffer</ref>[*indexptr]<sp/>=<sp/>bytedata;</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/>(*indexptr)<sp/>=<sp/>(*indexptr)<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/>errflag<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>errflag;</highlight></codeline>
<codeline lineno="115"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="eep.c"/>
  </compounddef>
</doxygen>
